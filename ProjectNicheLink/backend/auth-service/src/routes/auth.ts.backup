import { Router, Request, Response } from 'express';
export default router;

/**
 * @route POST /api/auth/login
 * @desc Login user with email and password
 * @access Public
 */
router.post('/login', validateLogin, async (req: Request, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    const { email, password } = req.body;

    const result = await authService.loginUser(email, password);
    logger.info(`User logged in successfully: ${email}`);

    return res.status(200).json({
      success: true,
      message: 'Login successful',
      data: {
        user: result.user,
        token: result.firebaseToken
      }
    });

  } catch (error) {
    logger.error('Login failed:', error);
    if (error instanceof Error) {
      if (error.message.includes('not found') || error.message.includes('Please register')) {
        return res.status(404).json({
          error: 'UserNotFound',
          message: 'User not found. Please register first.'
        });
      }
      if (error.message.includes('Firebase')) {
        return res.status(401).json({
          error: 'AuthenticationError',
          message: 'Authentication failed'
        });
      }
    }

    return res.status(500).json({
      error: 'InternalServerError',
      message: 'Login failed. Please try again.'
    });
  }
});
import { Router, Request, Response } from 'express';
export default router;

/**
 * @route POST /api/auth/login
 * @desc Login user with email and password
 * @access Public
 */
router.post('/login', validateLogin, async (req: Request, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    const { email, password } = req.body;

    const result = await authService.loginUser(email, password);
    logger.info(`User logged in successfully: ${email}`);

    return res.status(200).json({
      success: true,
      message: 'Login successful',
      data: {
        user: result.user,
        token: result.firebaseToken
      }
    });

  } catch (error) {
    logger.error('Login failed:', error);
    if (error instanceof Error) {
      if (error.message.includes('not found') || error.message.includes('Please register')) {
        return res.status(404).json({
          error: 'UserNotFound',
          message: 'User not found. Please register first.'
        });
      }
      if (error.message.includes('Firebase')) {
        return res.status(401).json({
          error: 'AuthenticationError',
          message: 'Authentication failed'
        });
      }
    }

    return res.status(500).json({
      error: 'InternalServerError',
      message: 'Login failed. Please try again.'
    });
  }
});
import { Router, Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import authService from '@/services/authService';
import { authenticateToken, requireSME } from '@/middleware/auth';
import { logger } from '@/utils/logger';

// Define user type locally
type UserRole = 'SME' | 'INFLUENCER' | 'ADMIN';

// Define authenticated request interface
interface AuthRequest extends Request {
  user: {
    uid: string;
    email: string;
    emailVerified: boolean;
    role: UserRole;
    userId: string;
    customClaims?: any;
  };
}

const router = Router();

// Validation middleware
const validateRegistration = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('fullName').trim().isLength({ min: 2 }).withMessage('Full name must be at least 2 characters'),
  body('role').isIn(['SME', 'INFLUENCER']).withMessage('Role must be SME or INFLUENCER'),
  body('phoneNumber').optional().isMobilePhone('any')
const validateLogin = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
];
];

const validateProfileUpdate = [
  body('fullName').optional().trim().isLength({ min: 2 }),
  body('phoneNumber').optional().isMobilePhone('any'),
  body('companyName').optional().trim().isLength({ min: 2 }),
  body('bio').optional().trim().isLength({ max: 500 })
];

/**
 * @route POST /api/auth/register
 * @desc Register a new user (SME or Influencer)
 * @access Public
 */
router.post('/register', validateRegistration, async (req: Request, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    const {
      email,
      password,
      fullName,
      role,
      phoneNumber,
      // SME fields
      companyName,
      companySize,
      industry,
      website,
      // Influencer fields
      dateOfBirth,
      gender,
      bio,
      socialPlatforms
    } = req.body;

    // Role-specific validation
    if (role === 'SME' && !companyName) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Company name is required for SME registration'
      });
    }

    if (role === 'INFLUENCER' && !bio) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Bio is required for Influencer registration'
      });
    }

    const userData = {
      email,
      password,
      fullName,
      role,
      phoneNumber,
      companyName,
      companySize,
      industry,
      website,
      dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : undefined,
      gender,
      bio,
      socialPlatforms
    };

    const result = await authService.registerUser(userData);

    logger.info(`User registered successfully: ${email} (${role})`);

    return res.status(201).json({
      success: true,
      message: 'User registered successfully. Please check your email for verification.',
      data: {
        user: result.user,
        firebase: result.firebaseUser
      }
    });

  } catch (error) {
    logger.error('Registration failed:', error);

    if (error instanceof Error) {
      if (error.message.includes('already exists')) {
        return res.status(409).json({
          error: 'ConflictError',
          message: 'User already exists with this email'
        });
      }

      if (error.message.includes('Firebase')) {
        return res.status(400).json({
          error: 'FirebaseError',
          message: 'Failed to create Firebase user'
        });
      }
    }

    return res.status(500).json({
      error: 'InternalServerError',
      message: 'Registration failed. Please try again.'
    });
  }
});

/**

/**
 * @route POST /api/auth/login
 * @desc Login user with email and password
 * @access Public
 */
router.post('/login', validateLogin, async (req: Request, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    const { email, password } = req.body;

    const result = await authService.loginUser(email, password);
    logger.info(`User logged in successfully: ${email}`);

    return res.status(200).json({
      success: true,
      message: 'Login successful',
      data: {
        user: result.user,
        token: result.firebaseToken
      }
    });

  } catch (error) {
    logger.error('Login failed:', error);
    if (error instanceof Error) {
      if (error.message.includes('not found') || error.message.includes('Please register')) {
        return res.status(404).json({
          error: 'UserNotFound',
          message: 'User not found. Please register first.'
        });
      }
      if (error.message.includes('Firebase')) {
        return res.status(401).json({
          error: 'AuthenticationError',
          message: 'Authentication failed'
        });
      }
    }

    return res.status(500).json({
      error: 'InternalServerError',
      message: 'Login failed. Please try again.'
    });
  }
});
 * @route POST /api/auth/verify-email
 * @desc Verify email and activate user account
 * @access Public (requires Firebase token)
 */
router.post('/verify-email', authenticateToken, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { uid } = req.user;

    const user = await authService.verifyEmailAndActivateUser(uid);

    logger.info(`Email verified for user: ${user.email}`);

    return res.json({
      success: true,
      message: 'Email verified successfully. Account is now active.',
      data: { user }
    });

  } catch (error) {
    logger.error('Email verification failed:', error);

    return res.status(400).json({
      error: 'VerificationError',
      message: 'Email verification failed'
    });
  }
});

/**
 * @route GET /api/auth/profile
 * @desc Get current user profile
 * @access Private
 */
router.get('/profile', authenticateToken, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { userId } = req.user;

    const user = await authService.getUserProfile(userId);

    return res.json({
      success: true,
      data: { user }
    });

  } catch (error) {
    logger.error('Failed to get user profile:', error);

    return res.status(404).json({
      error: 'NotFoundError',
      message: 'User profile not found'
    });
  }
});

/**
 * @route PUT /api/auth/profile
 * @desc Update user profile
 * @access Private
 */
router.put('/profile', authenticateToken, validateProfileUpdate, async (req: Request, res: Response) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'ValidationError',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { userId } = req.user;
    const updateData = req.body;

    const user = await authService.updateUserProfile(userId, updateData);

    logger.info(`Profile updated for user: ${user.email}`);

    return res.json({
      success: true,
      message: 'Profile updated successfully',
      data: { user }
    });

  } catch (error) {
    logger.error('Profile update failed:', error);

    return res.status(400).json({
      error: 'UpdateError',
      message: 'Failed to update profile'
    });
  }
});

/**
 * @route POST /api/auth/resend-verification
 * @desc Resend email verification
 * @access Private
 */
router.post('/resend-verification', authenticateToken, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { uid } = req.user;

    await authService.sendEmailVerification(uid);

    return res.json({
      success: true,
      message: 'Verification email sent successfully'
    });

  } catch (error) {
    logger.error('Failed to resend verification email:', error);

    return res.status(400).json({
      error: 'EmailError',
      message: 'Failed to send verification email'
    });
  }
});

/**
 * @route DELETE /api/auth/account
 * @desc Delete user account
 * @access Private
 */
router.delete('/account', authenticateToken, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { userId } = req.user;

    await authService.deleteUser(userId);

    logger.info(`User account deleted: ${userId}`);

    return res.json({
      success: true,
      message: 'Account deleted successfully'
    });

  } catch (error) {
    logger.error('Account deletion failed:', error);

    return res.status(400).json({
      error: 'DeletionError',
      message: 'Failed to delete account'
    });
  }
});

/**
 * @route GET /api/auth/smes
 * @desc Get list of SME users (for admin or public browsing)
 * @access Private
 */
router.get('/smes', authenticateToken, async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;

    const result = await authService.getUsersByRole('SME', page, limit);

    res.json({
      success: true,
      data: result
    });

  } catch (error) {
    logger.error('Failed to get SME users:', error);

    res.status(400).json({
      error: 'QueryError',
      message: 'Failed to retrieve SME users'
    });
  }
});

/**
 * @route GET /api/auth/influencers
 * @desc Get list of Influencer users (for SMEs to browse)
 * @access Private (SME only)
 */
router.get('/influencers', authenticateToken, requireSME, async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;

    const result = await authService.getUsersByRole('INFLUENCER', page, limit);

    res.json({
      success: true,
      data: result
    });

  } catch (error) {
    logger.error('Failed to get Influencer users:', error);

    res.status(400).json({
      error: 'QueryError',
      message: 'Failed to retrieve Influencer users'
    });
  }
});

/**
 * @route GET /api/auth/me
 * @desc Get current user's complete profile
 * @access Private
 */
router.get('/me', authenticateToken, async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        error: 'Unauthorized',
        message: 'User not authenticated'
      });
    }

    const { uid, userId, email, role, emailVerified } = req.user;

    const profile = await authService.getUserProfile(userId);

    return res.json({
      success: true,
      data: {
        firebase: {
          uid,
          email,
          emailVerified
        },
        profile: {
          ...profile,
          role
        }
      }
    });

  } catch (error) {
    logger.error('Failed to get user info:', error);

    return res.status(400).json({
      error: 'ProfileError',
      message: 'Failed to get user information'
    });
  }
});

export default router;
